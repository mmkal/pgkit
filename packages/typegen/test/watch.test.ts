import * as fs from 'fs'
import * as fsSyncer from 'fs-syncer'
import * as path from 'path'

import {test as _test, beforeEach, expect, vi as jest} from 'vitest'

import * as typegen from '../src'
import {getPureHelper as getHelper} from './helper'

export const {typegenOptions, logger, poolHelper: helper} = getHelper({__filename})

beforeEach(async () => {
  jest.clearAllMocks()
  await helper.setupDb()
})

const test = process.env.CI ? _test.skip : _test

test(
  'watch file system',
  async () => {
    const syncer = fsSyncer.testFixture({
      expect,
      targetState: {
        'file1.ts': `
          import {sql} from '@pgkit/client'
          export default sql\`select 123 as abc\`
        `,
        'file2.ts': `
          import {sql} from '@pgkit/client'
          export default sql\`select 123 as xyz\`
        `,
      },
    })

    syncer.sync()

    const {watch} = await typegen.generate(typegenOptions(syncer.baseDir))

    expect(syncer.yaml()).toMatchInlineSnapshot(`
      "---
      file1.ts: |-
        import {sql} from '@pgkit/client'
        export default sql<queries.Abc>\`select 123 as abc\`

        export declare namespace queries {
          // Generated by @pgkit/typegen

          /** - query: \`select 123 as abc\` */
          export interface Abc {
            /** not null: \`true\`, regtype: \`integer\` */
            abc: number
          }
        }

      file2.ts: |-
        import {sql} from '@pgkit/client'
        export default sql<queries.Xyz>\`select 123 as xyz\`

        export declare namespace queries {
          // Generated by @pgkit/typegen

          /** - query: \`select 123 as xyz\` */
          export interface Xyz {
            /** not null: \`true\`, regtype: \`integer\` */
            xyz: number
          }
        }
      "
    `)

    const watcher = watch()

    await waitForLog(/Watching for file changes/)
    await waitForLog(/Initial codegen complete/)
    fs.writeFileSync(
      path.join(syncer.baseDir, 'file1.ts'),
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      syncer.read()['file1.ts'].replace('select 123 as abc', 'select 123 as def'),
    )
    await waitForLog(/file1.ts was changed, running codegen/)

    await watcher.close()

    expect(syncer.yaml()).toMatchInlineSnapshot(`
      "---
      file1.ts: |-
        import {sql} from '@pgkit/client'
        export default sql<queries.Def>\`select 123 as def\`

        export declare namespace queries {
          // Generated by @pgkit/typegen

          /** - query: \`select 123 as def\` */
          export interface Def {
            /** not null: \`true\`, regtype: \`integer\` */
            def: number
          }
        }

      file2.ts: |-
        import {sql} from '@pgkit/client'
        export default sql<queries.Xyz>\`select 123 as xyz\`

        export declare namespace queries {
          // Generated by @pgkit/typegen

          /** - query: \`select 123 as xyz\` */
          export interface Xyz {
            /** not null: \`true\`, regtype: \`integer\` */
            xyz: number
          }
        }
      "
    `)

    // below assertion fails - bug in chokidar?
    // const watchLogs = JSON.stringify(logger.info.mock.calls, null, 2)
    // expect(watchLogs, `logs: ${watchLogs}`).not.toContain('file2.ts')
  },
  {retry: 3},
)

test(
  'lazily watch file system',
  async () => {
    const syncer = fsSyncer.testFixture({
      expect,
      targetState: {
        'file1.ts': `
          import {sql} from '@pgkit/client'
          export default sql\`select 123 as abc\`
        `,
      },
    })

    syncer.sync()

    const {watch} = await typegen.generate({
      ...typegenOptions(syncer.baseDir),
      lazy: true,
    })

    expect(logger.info).toHaveBeenCalledTimes(1)

    const watcher = watch()

    await waitForLog(/Watching for file changes/)
    fs.writeFileSync(
      path.join(syncer.baseDir, 'file1.ts'),
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      syncer.read()['file1.ts'].replace('select 123 as abc', 'select 123 as def'),
    )
    await waitForLog(/file1.ts was changed, running codegen/)

    await watcher.close()

    expect(syncer.yaml()).toMatchInlineSnapshot(`
      "---
      file1.ts: |-
        import {sql} from '@pgkit/client'
        export default sql<queries.Def>\`select 123 as def\`

        export declare namespace queries {
          // Generated by @pgkit/typegen

          /** - query: \`select 123 as def\` */
          export interface Def {
            /** not null: \`true\`, regtype: \`integer\` */
            def: number
          }
        }
      "
    `)
  },
  {retry: 3},
)

const waitForLog = async (match: RegExp, timeoutMs = 3000) => {
  return new Promise<void>((resolve, reject) => {
    const start = Date.now()
    const end = start + timeoutMs
    const check = () => {
      const jsonLogs = JSON.stringify(logger.info.mock.calls, null, 2)
      if (match.test(jsonLogs)) {
        resolve()
      } else if (Date.now() > end) {
        reject(
          new Error(
            `Logs matching /${match.source}/ not found after ${timeoutMs}ms. Calls: ${JSON.stringify(logger.info.mock.calls, null, 2)}`,
            {cause: logger.info.mock.calls},
          ),
        )
      } else {
        setTimeout(check, 20)
      }
    }

    check()
  })
}
